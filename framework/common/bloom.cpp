
#include <stdio.h>
#include <string.h>
#include <stdint.h>
#include <string>
#include <vector>

namespace common {

    uint32_t hash(const char* data, size_t n, uint32_t seed) {

        const uint32_t m = 0xc6a4a793;
        const uint32_t r = 24;
        const char* limit = data + n;
        uint32_t h = seed ^ (n * m);

        while (data + 4 <= limit) {
            uint32_t w = *((uint32_t *)data);
            data += 4;
            h += w;
            h *= m;
            h ^= (h >> 16);
        }

        switch (limit - data) {                                                                                                                                                                  case 3:
                h += static_cast<unsigned char>(data[2]) << 16;
                [[fallthrough]]; 
            case 2:
                h += static_cast<unsigned char>(data[1]) << 8;
                [[fallthrough]]; 
            case 1:
                h += static_cast<unsigned char>(data[0]);
                h *= m;
                h ^= (h >> r);
                break;
        }
        return h;
    }

    uint32_t bloomHash(const std::string &key) {
        return common::hash(key.c_str(), key.size(), 0xbc9f1d34);
    }

    bool KeyMayMatchInternal(uint32_t h, uint32_t delta, const std::string &filter)
    {
        const size_t len = filter.size();
        if (len < 2)
            return false;

        const char *array = filter.c_str();
        const size_t bits = (len - 1) * 8;

        // Use the encoded k so that we can read filters generated by
        // bloom filters created using different parameters.
        const size_t k = array[len - 1];
        if (k > 30)
        {
            // Reserved for potentially new encodings for short bloom filters.
            // Consider it a match.
            return true;
        }

        for (size_t j = 0; j < k; j++)
        {
            const uint32_t bitpos = h % bits;
            if ((array[bitpos / 8] & (1 << (bitpos % 8))) == 0)
                return false;
            h += delta;
        }
        return true;
    }

    bool keyMayMatch(const std::string &key, const std::vector<const std::string *> &filter_vec){
        if (filter_vec.size() == 0)
        {
            return false;
        }
        uint32_t h = bloomHash(key);
        const uint32_t delta = (h >> 17) | (h << 15);
        for (auto iter = filter_vec.begin(); iter != filter_vec.end(); iter++)
        {
            if (KeyMayMatchInternal(h, delta, *(*iter)))
                return true;
        }
        return false;
    }

    bool keyMayMatch(const std::string &key, const std::string &filter) {

        const size_t len = filter.size();
        if (len < 2)  
            return false;

        const char* array = filter.c_str();
        const size_t bits = (len - 1) * 8;

        const size_t k = array[len - 1]; 
        if (k > 30) 
          return true;
 

        uint32_t h = bloomHash(key);
        const uint32_t delta = (h >> 17) | (h << 15);
        for (size_t j = 0; j < k; j++) {
            const uint32_t bitpos = h % bits;
            if ((array[bitpos / 8] & (1 << (bitpos % 8))) == 0)  
                return false;
    
            h += delta;
        }   
        return true;
    }

}; //namespace common